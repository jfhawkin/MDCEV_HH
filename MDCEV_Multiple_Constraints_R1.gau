/*written by C. Bhat, June 2007 */
/* Modified lines 56-60 June 2009 */
/* Modified by J. Hawkins, October 2018 to accomodate multiple constraints for time and money */
/* This is code for MDCEV model (with no mixing) for the consumption case with outside good(s) ;
The code assumes fixed alpha and fixed gamma values across individuals, but can be easily modified to allow varying
alpha/gamma values across individuals due to observed variables;
The code can also be extended in a straightforwardway to allow random coefficients/error components through mixing.

Before using this code, the reader should read Bhat (2007) "The Multiple Discrete-Continuous Extreme Value (MDCEV) Model: Role of Utility Function Parameters, Identification Considerations,
and Model Extensions," Technical paper, Department of Civil Engineering, The University of Texas at Austin, at http://www.caee.utexas.edu/prof/bhat/MDCEV.html */

library maxlik;
maxset;

/*****************************************************************************
Global Variable Definitions
*****************************************************************************/
clearg __row,nobs,_config,_alp0to1,_price,nct,ncg,datatset,_po,nvarmt,nvarmg,nvarmw,nvarall,nvargamt,nvargamg;

__row = 1000;  // Number of rows to be read at a time by the log-likelihood function
nobs  = 7026; // Number of observations in the dataset
numout   = 1;    // Number of outside goods (i.e., always consumed goods) per time and goods
_price   = 0;    // 1 if there is price variation across goods, 0 otherwise
nct   = 13;    // Number of alternatives (in the universal choice set) including outside goods for time allocation
ncg   = 15;    // Number of alternatives (in the universal choice set) including outside goods for goods consumption
nw    = 1;    // Number of work alternatives (in the universal choice set)

// MUST RUN WHEN UPDATING ESTIMATION DATA
//in_data = csvReadM("est_data.csv", 2);
//string var_names = {"caseid", "uno", "sero", "householdid", "personnumber", "occupation", "triprecords", "hhsize", "hhworkers", "hhworkersFT", "hhworkersPT", "hhstudents",
// "incomeclass", "income", "pincome", "wage", "dwellingtype", "vehicles", "schooltrips", "hhtrips", "workhome", "hhchildren", "hhadults", "worktrips", "age", "transitpass", "sex", "license", 
// "vehlic", "studentstatus", "employmentstatus", "empfull", "emppart", "emphome", "empnone", "time1", "time2", "time3", "time4", "time5", "time6", "time7", "time8", "time9", "time10", 
// "time11", "time12", "time13", "timew", "consume1", "consume2", "consume3", "consume4", "consume5", "consume6", "consume7", "consume8", "consume9", "consume10", "consume11", "consume12",
// "consume13", "consume14", "consume15"};
//dataset = saved(in_data, "est_data.dat", var_names);

dataset  = "est_data.dat";

{ pointer,_po } = indices(dataset,"caseid"); // position of pointer to case number in data set,
// modify if the case number column has a name different than "caseid"

/*****************************************************************************
Variable Specification Area
*****************************************************************************/
/* Position of UNO variable (i.e., the column of ones) in data set.
The dataset should consist of a column of ones.
Modify if the label (in double-quotes) of the column of ones in your dataset is different from "uno"  */

{ unov,ivuno } = indices(dataset,"uno");

/* Position of SERO variable (i.e., the column of zeros) in data set.
The dataset should consist of a column of zeros.
Modify if the label (in double-quotes) of the column of zeros in your dataset is different from "sero"  */

{ serov,ivsero } = indices(dataset,"sero");

/* Position of WEIGHT variable (i.e., the column of weights).
If the data hasweights, then the dataset should consist of a column of weights.
Modify the label (in double-quotes)with the label of theweight variable, if your data has weights  */

{weight,wtind } = indices(dataset,"uno");

/* Positions of the DEPENDENT Variables (i.e., the consumption quantities for each alternative - NOT consumption expenditures for each alternative).
Provide labels (one label in each double-quote) of the dependent variables (i.e., consumption quantities) in your dataset.
Number of labels = number of alternatives. */

/* Note however that the likelihood function iswritten to be based on the probability of consumption expenditures - Equation 19 of Bhat 2008. */
// Define separate functions for time consumption, ft, and goods consumption, fg. Parallel structureswith separate baseline utility functions.

{ choicmt,fw } = indices(dataset,"empnone");

{ choicmt,ftw } = indices(dataset,"timew"|"time1"|"time2"|"time3"|"time4"|"time5"|"time6"|"time7"|"time8"|"time9"|"time10"|"time11"|"time12"|"time13");
{ choicmt,ftnw } = indices(dataset,"time1"|"time2"|"time3"|"time4"|"time5"|"time6"|"time7"|"time8"|"time9"|"time10"|"time11"|"time12"|"time13");
{ choicmg,fg } = indices(dataset,"consume1"|"consume2"|"consume3"|"consume4"|"consume5"|"consume6"|"consume7"|"consume8"|"consume9"|"consume10"|"consume11"|"consume12"|"consume13"|"consume14"|"consume15");

/* Positions of PRICE variables.
Provide labels of price variables (one label in each double-quote). Number of labels = number of alternatives.
First good (i.e., outside good, or the first of the outside goods if there are several) should be specified as a numeraire goodwith price one (UNO)
Provide all UNO variables if there is no price variation */

{ cprice,fp } = indices(dataset,"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno"|"uno");
{ cinc,fi }   = indices(dataset,"wage");

/* Definition of INDEPENDENT variables.
First 'numout' goods are those that are always consumed (i.e., the outside goods), and the first good is numeraire.
In the following specification, ivm1, ivm2, ivm3 contain independent variable specifications (on right hand side) for baseline utility (PSI) for alternatives 1, 2, and 3;
Add a row for ivm4 below if there is a 4th alternative, another addiitonal row for ivm5 if there is a 5th alternative, ... (number of rows = number of alternatives);
Number of columns = Number of variables including alternative specific constants; consider first alternative as base  */

let ivmw  = { sex };

//let ivm1t  = { sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm2t  = { uno  sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm3t  = { sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm4t  = { sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm5t  = { sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm6t  = { sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm7t  = { sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm8t  = { sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm9t  = { sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm10t = { sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm11t = { sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm12t = { sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero };
//let ivm13t = { sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone };
let ivmwt  = { sero sero sero sero sero sero sero sero sero sero sero sero sero sero   sero sero sero sero sero sero sero sero sero sero sero sero };
let ivm1t  = { uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero sero sero };
let ivm2t  = { sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero sero };
let ivm3t  = { sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero };
let ivm4t  = { sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero };
let ivm5t  = { sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero };
let ivm6t  = { sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero };
let ivm7t  = { sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero };
let ivm8t  = { sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero };
let ivm9t  = { sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero };
let ivm10t = { sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero };
let ivm11t = { sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero };
let ivm12t = { sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero };
let ivm13t = { sero sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero hhsize };

//let ivm1g  = { sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm2g  = { uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm3g  = { sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm4g  = { sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm5g  = { sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm6g  = { sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm7g  = { sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm8g  = { sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm9g  = { sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm10g = { sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm11g = { sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm12g = { sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm13g = { sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero sero sero sero sero sero sero };
//let ivm14g = { sero sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone sero sero sero sero sero sero };
//let ivm15g = { sero sero sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize vehicles empfull emppart emphome empnone };

let ivm1g  = { sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero sero };
let ivm2g  = { uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero sero sero sero };
let ivm3g  = { sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero sero sero };
let ivm4g  = { sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero sero };
let ivm5g  = { sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero sero };
let ivm6g  = { sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero sero };
let ivm7g  = { sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero sero };
let ivm8g  = { sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero sero };
let ivm9g  = { sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero sero };
let ivm10g = { sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero sero };
let ivm11g = { sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero sero };
let ivm12g = { sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero sero };
let ivm13g = { sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero sero };
let ivm14g = { sero sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize sero };
let ivm15g = { sero sero sero sero sero sero sero sero sero sero sero sero sero uno  sero sero sero sero sero sero sero sero sero sero sero sero sero hhsize };

/* The above specification is for the following baseline utility expressions

Psi1 = exp( beta1*0  +  beta2*0  +   beta3*0   +  beta4*0   + beta5*0   + beta6*0   + beta7*0   + beta8*0)
Psi2 = exp( beta1*1  +  beta2*0  +   beta3*0   +  beta4*0   + beta5*hhsize + beta6*0   + beta7*0   + beta8*0)
Psi3 = exp( beta1*0  +  beta2*1  +   beta3*0   +  beta4*0   + beta5*0   + beta6*hhsize + beta7*0   + beta8*0)
Psi4 = exp( beta1*0  +  beta2*0  +   beta3*1   +  beta4*0   + beta5*0   + beta6*0   + beta7*hhsize + beta8*0)
Psi5 = exp( beta1*0  +  beta2*0  +   beta3*0   +  beta4*1   + beta5*0   + beta6*0   + beta7*0   + beta8*hhsize) */

/* Add a row for v4 below if there is a 4th alternative, another additional row for v5 if there is a 5th alternative,.... (number of rows = number of alternatives) */

{ vw,ivmww }      = indices(dataset,ivmw');

{ vtw,ivmwtt }   = indices(dataset,ivmwt');
{ vt1,ivm1tt }   = indices(dataset,ivm1t');
{ vt2,ivm2tt }   = indices(dataset,ivm2t');
{ vt3,ivm3tt }   = indices(dataset,ivm3t');
{ vt4,ivm4tt }   = indices(dataset,ivm4t');
{ vt5,ivm5tt }   = indices(dataset,ivm5t');
{ vt6,ivm6tt }   = indices(dataset,ivm6t');
{ vt7,ivm7tt }   = indices(dataset,ivm7t');
{ vt8,ivm8tt }   = indices(dataset,ivm8t');
{ vt9,ivm9tt }   = indices(dataset,ivm9t');
{ vt10,ivm10tt } = indices(dataset,ivm10t');
{ vt11,ivm11tt } = indices(dataset,ivm11t');
{ vt12,ivm12tt } = indices(dataset,ivm12t');
{ vt13,ivm13tt } = indices(dataset,ivm13t');

{ vg1,ivm1gg }   = indices(dataset,ivm1g');
{ vg2,ivm2gg }   = indices(dataset,ivm2g');
{ vg3,ivm3gg }   = indices(dataset,ivm3g');
{ vg4,ivm4gg }   = indices(dataset,ivm4g');
{ vg5,ivm5gg }   = indices(dataset,ivm5g');
{ vg6,ivm6gg }   = indices(dataset,ivm6g');
{ vg7,ivm7gg }   = indices(dataset,ivm7g');
{ vg8,ivm8gg }   = indices(dataset,ivm8g');
{ vg9,ivm9gg }   = indices(dataset,ivm9g');
{ vg10,ivm10gg } = indices(dataset,ivm10g');
{ vg11,ivm11gg } = indices(dataset,ivm11g');
{ vg12,ivm12gg } = indices(dataset,ivm12g');
{ vg13,ivm13gg } = indices(dataset,ivm13g');
{ vg14,ivm14gg } = indices(dataset,ivm14g');
{ vg15,ivm15gg } = indices(dataset,ivm15g');

/* Define labels of the parameters in the baseline utility for output printing;
Provide as many parameter labels as the number of columns in ivm1 (i.e., the number of variables in the Psi function) for each of work, time, and goods consumption */

//varnamt = "ASC-2t"|"ASC-3t"|"ASC-4t"|"ASC-5t"|"ASC-6t"|"ASC-7t"|"ASC-8t"|"ASC-9t"|"ASC-10t"|"ASC-11t"|"ASC-12t"|"ASC-13t"|"hsz-2t"|"hsz-3t"|"hsz-4t"|"hsz-5t"|"hsz-6t"|"hsz-7t"|"hsz-8t"|"hsz-9t"|"hsz-10t"|"hsz-11t"|"hsz-12t"|"hsz-13t"|"veh-2t"|"veh-3t"|"veh-4t"|"veh-5t"|"veh-6t"|"veh-7t"|"veh-8t"|"veh-9t"|"veh-10t"|"veh-11t"|"veh-12t"|"veh-13t"|"wft-2t"|"wft-3t"|"wft-4t"|"wft-5t"|"wft-6t"|"wft-7t"|"wft-8t"|"wft-9t"|"wft-10t"|"wft-11t"|"wft-12t"|"wft-13t"|"wpt-2t"|"wpt-3t"|"wpt-4t"|"wpt-5t"|"wpt-6t"|"wpt-7t"|"wpt-8t"|"wpt-9t"|"wpt-10t"|"wpt-11t"|"wpt-12t"|"wpt-13t"|"who-2t"|"who-3t"|"who-4t"|"who-5t"|"who-6t"|"who-7t"|"who-8t"|"who-9t"|"who-10t"|"who-11t"|"who-12t"|"who-13t"|"wno-2t"|"wno-3t"|"wno-4t"|"wno-5t"|"wno-6t"|"wno-7t"|"wno-8t"|"wno-9t"|"wno-10t"|"wno-11t"|"wno-12t"|"wno-13t";
//varnamg = "ASC-2g"|"ASC-3g"|"ASC-4g"|"ASC-5g"|"ASC-6g"|"ASC-7g"|"ASC-8g"|"ASC-9g"|"ASC-10g"|"ASC-11g"|"ASC-12g"|"ASC-13g"|"ASC-14g"|"ASC-15g"|"hsz-2g"|"hsz-3g"|"hsz-4g"|"hsz-5g"|"hsz-6g"|"hsz-7g"|"hsz-8g"|"hsz-9g"|"hsz-10g"|"hsz-11g"|"hsz-12g"|"hsz-13g"|"hsz-14g"|"hsz-15g"|"veh-2g"|"veh-3g"|"veh-4g"|"veh-5g"|"veh-6g"|"veh-7g"|"veh-8g"|"veh-9g"|"veh-10g"|"veh-11g"|"veh-12t"|"veh-13g"|"veh-14g"|"veh-15g"|"wft-2g"|"wft-3t"|"wft-4g"|"wft-5g"|"wft-6g"|"wft-7g"|"wft-8g"|"wft-9g"|"wft-10g"|"wft-11g"|"wft-12g"|"wft-13g"|"wft-14g"|"wft-15g"|"wpt-2g"|"wpt-3g"|"wpt-4g"|"wpt-5g"|"wpt-6g"|"wpt-7g"|"wpt-8g"|"wpt-9g"|"wpt-10g"|"wpt-11g"|"wpt-12g"|"wpt-13g"|"wpt-14g"|"wpt-15g"|"who-2g"|"who-3g"|"who-4g"|"who-5g"|"who-6g"|"who-7g"|"who-8g"|"who-9g"|"who-10g"|"who-11g"|"who-12g"|"who-13g"|"who-14g"|"who-15g"|"wno-2g"|"wno-3g"|"wno-4g"|"wno-5g"|"wno-6g"|"wno-7g"|"wno-8g"|"wno-9g"|"wno-10g"|"wno-11g"|"wno-12g"|"wno-13g"|"wno-14g"|"wno-15g";

varnamw = "sex";
varnamt = "ASC-1t"|"ASC-2t"|"ASC-3t"|"ASC-4t"|"ASC-5t"|"ASC-6t"|"ASC-7t"|"ASC-8t"|"ASC-9t"|"ASC-10t"|"ASC-11t"|"ASC-12t"|"ASC-13t"|"hsz-1t"|"hsz-2t"|"hsz-3t"|"hsz-4t"|"hsz-5t"|"hsz-6t"|"hsz-7t"|"hsz-8t"|"hsz-9t"|"hsz-10t"|"hsz-11t"|"hsz-12t"|"hsz-13t";
varnamg = "ASC-2g"|"ASC-3g"|"ASC-4g"|"ASC-5g"|"ASC-6g"|"ASC-7g"|"ASC-8g"|"ASC-9g"|"ASC-10g"|"ASC-11g"|"ASC-12g"|"ASC-13g"|"ASC-14g"|"ASC-15g"|"hsz-2g"|"hsz-3g"|"hsz-4g"|"hsz-5g"|"hsz-6g"|"hsz-7g"|"hsz-8g"|"hsz-9g"|"hsz-10g"|"hsz-11g"|"hsz-12g"|"hsz-13g"|"hsz-14g"|"hsz-15g";

/* In the following specification, ivg1, ivg2, ivg3 contain input data specifications (on the right hand side) for translation parameters (gammas) for alternatives 1, 2, and 3;
Add a row for ivg4 if there is a 4th alternative, another additional row for ivd5 if there is a 5th alternative,....(number of rows = number of alternatives);
Number of columns = Number of alternatives; Note that you can also add individual-specific variables below, so that gamma varies across individuals; However,
youwill then have to translate ofpwutputs to compute actual gamma parameters; This code iswritten to provide youwith the gamma parameters directly for the casewhen
there is no variation in gamma across individuals; Since gamma=0 for the outside goods, the first numout columns of the ivg vectorswill be sero */

let ivgwtw  = { sero sero sero  sero  sero  sero sero sero sero sero sero sero sero sero };
let ivg1tw  = { sero uno  sero  sero  sero  sero sero sero sero sero sero sero sero sero };
let ivg2tw  = { sero sero uno   sero sero  sero  sero sero sero sero sero sero sero sero };
let ivg3tw  = { sero sero sero  uno  sero  sero  sero sero sero sero sero sero sero sero };
let ivg4tw  = { sero sero sero  sero uno   sero  sero sero sero sero sero sero sero sero };
let ivg5tw  = { sero sero sero  sero sero  uno   sero sero sero sero sero sero sero sero };
let ivg6tw  = { sero sero sero  sero sero  sero  uno  sero sero sero sero sero sero sero };
let ivg7tw  = { sero sero sero  sero sero  sero  sero uno  sero sero sero sero sero sero };
let ivg8tw  = { sero sero sero  sero sero  sero  sero sero uno  sero sero sero sero sero };
let ivg9tw  = { sero sero sero  sero sero  sero  sero sero sero uno  sero sero sero sero };
let ivg10tw = { sero sero sero  sero sero  sero  sero sero sero sero uno  sero sero sero };
let ivg11tw = { sero sero sero  sero sero  sero  sero sero sero sero sero uno  sero sero };
let ivg12tw = { sero sero sero  sero sero  sero  sero sero sero sero sero sero uno  sero };
let ivg13tw = { sero sero sero  sero sero  sero  sero sero sero sero sero sero sero uno  };

let ivg1tnw  = { sero sero  sero  sero  sero sero sero sero sero sero sero sero sero };
let ivg2tnw  = { sero uno   sero sero  sero  sero sero sero sero sero sero sero sero };
let ivg3tnw  = { sero sero  uno  sero  sero  sero sero sero sero sero sero sero sero };
let ivg4tnw  = { sero sero  sero uno   sero  sero sero sero sero sero sero sero sero };
let ivg5tnw  = { sero sero  sero sero  uno   sero sero sero sero sero sero sero sero };
let ivg6tnw  = { sero sero  sero sero  sero  uno  sero sero sero sero sero sero sero };
let ivg7tnw  = { sero sero  sero sero  sero  sero uno  sero sero sero sero sero sero };
let ivg8tnw  = { sero sero  sero sero  sero  sero sero uno  sero sero sero sero sero };
let ivg9tnw  = { sero sero  sero sero  sero  sero sero sero uno  sero sero sero sero };
let ivg10tnw = { sero sero  sero sero  sero  sero sero sero sero uno  sero sero sero };
let ivg11tnw = { sero sero  sero sero  sero  sero sero sero sero sero uno  sero sero };
let ivg12tnw = { sero sero  sero sero  sero  sero sero sero sero sero sero uno  sero };
let ivg13tnw = { sero sero  sero sero  sero  sero sero sero sero sero sero sero uno  };

let ivg1g  = { sero sero  sero sero  sero  sero sero sero sero sero sero sero sero sero sero };
let ivg2g  = { sero uno   sero sero  sero  sero sero sero sero sero sero sero sero sero sero };
let ivg3g  = { sero sero  uno  sero  sero  sero sero sero sero sero sero sero sero sero sero };
let ivg4g  = { sero sero  sero uno   sero  sero sero sero sero sero sero sero sero sero sero };
let ivg5g  = { sero sero  sero sero  uno   sero sero sero sero sero sero sero sero sero sero };
let ivg6g  = { sero sero  sero sero  sero  uno  sero sero sero sero sero sero sero sero sero };
let ivg7g  = { sero sero  sero sero  sero  sero uno  sero sero sero sero sero sero sero sero };
let ivg8g  = { sero sero  sero sero  sero  sero sero uno  sero sero sero sero sero sero sero };
let ivg9g  = { sero sero  sero sero  sero  sero sero sero uno  sero sero sero sero sero sero };
let ivg10g = { sero sero  sero sero  sero  sero sero sero sero uno  sero sero sero sero sero };
let ivg11g = { sero sero  sero sero  sero  sero sero sero sero sero uno  sero sero sero sero };
let ivg12g = { sero sero  sero sero  sero  sero sero sero sero sero sero uno  sero sero sero };
let ivg13g = { sero sero  sero sero  sero  sero sero sero sero sero sero sero uno  sero sero };
let ivg14g = { sero sero  sero sero  sero  sero sero sero sero sero sero uno  sero uno  sero };
let ivg15g = { sero sero  sero sero  sero  sero sero sero sero sero sero sero uno  sero uno  };

/* The above specification is for the following definitions of Translation parameters

Gamma1 = exp( phi1*0   + phi2*0  +  phi3*0  +  phi4*0  +  phi5*0) = exp(0), but later converted to exp(-1000)=0,
Gamma2 = exp( phi1*0   + phi2*1  +  phi3*0  +  phi4*0  +  phi5*0) = exp(phi2)
Gamma3 = exp( phi1*0   + phi2*0  +  phi3*1  +  phi4*0  +  phi5*0) = exp(phi3)
Gamma4 = exp( phi1*0   + phi2*0  +  phi3*1  +  phi4*1  +  phi5*0) = exp(phi4)
Gamma5 = exp( phi1*0   + phi2*0  +  phi3*1  +  phi4*0  +  phi5*1) = exp(phi5)*/

//Add a row for u4 below if there is a 4th alternative,... (number of rows = number of alternatives)

{ utw,ivgwttw }   = indices(dataset,ivgwtw');
{ ut1,ivg1ttw }   = indices(dataset,ivg1tw');
{ ut2,ivg2ttw }   = indices(dataset,ivg2tw');
{ ut3,ivg3ttw }   = indices(dataset,ivg3tw');
{ ut4,ivg4ttw }   = indices(dataset,ivg4tw');
{ ut5,ivg5ttw }   = indices(dataset,ivg5tw');
{ ut6,ivg6ttw }   = indices(dataset,ivg6tw');
{ ut7,ivg7ttw }   = indices(dataset,ivg7tw');
{ ut8,ivg8ttw }   = indices(dataset,ivg8tw');
{ ut9,ivg9ttw }   = indices(dataset,ivg9tw');
{ ut10,ivg10ttw } = indices(dataset,ivg10tw');
{ ut11,ivg11ttw } = indices(dataset,ivg11tw');
{ ut12,ivg12ttw } = indices(dataset,ivg12tw');
{ ut13,ivg13ttw } = indices(dataset,ivg13tw');

{ ut1,ivg1ttnw }   = indices(dataset,ivg1tnw');
{ ut2,ivg2ttnw }   = indices(dataset,ivg2tnw');
{ ut3,ivg3ttnw }   = indices(dataset,ivg3tnw');
{ ut4,ivg4ttnw }   = indices(dataset,ivg4tnw');
{ ut5,ivg5ttnw }   = indices(dataset,ivg5tnw');
{ ut6,ivg6ttnw }   = indices(dataset,ivg6tnw');
{ ut7,ivg7ttnw }   = indices(dataset,ivg7tnw');
{ ut8,ivg8ttnw }   = indices(dataset,ivg8tnw');
{ ut9,ivg9ttnw }   = indices(dataset,ivg9tnw');
{ ut10,ivg10ttnw } = indices(dataset,ivg10tnw');
{ ut11,ivg11ttnw } = indices(dataset,ivg11tnw');
{ ut12,ivg12ttnw } = indices(dataset,ivg12tnw');
{ ut13,ivg13ttnw } = indices(dataset,ivg13tnw');

{ u1,ivg1gg }   = indices(dataset,ivg1g');
{ u2,ivg2gg }   = indices(dataset,ivg2g');
{ u3,ivg3gg }   = indices(dataset,ivg3g');
{ u4,ivg4gg }   = indices(dataset,ivg4g');
{ u5,ivg5gg }   = indices(dataset,ivg5g');
{ u6,ivg6gg }   = indices(dataset,ivg6g');
{ u7,ivg7gg }   = indices(dataset,ivg7g');
{ u8,ivg8gg }   = indices(dataset,ivg8g');
{ u9,ivg9gg }   = indices(dataset,ivg9g');
{ u10,ivg10gg } = indices(dataset,ivg10g');
{ u11,ivg11gg } = indices(dataset,ivg11g');
{ u12,ivg12gg } = indices(dataset,ivg12g');
{ u12,ivg13gg } = indices(dataset,ivg13g');
{ u12,ivg14gg } = indices(dataset,ivg14g');
{ u12,ivg15gg } = indices(dataset,ivg15g');

// Buld the utility function component for work/no work
ivmw = ivmww';
// Build utility function components for time consumption
ivmtw =  ivmwtt'~ivm1tt'~ivm2tt'~ivm3tt'~ivm4tt'~ivm5tt'~ivm6tt'~ivm7tt'~ivm8tt'~ivm9tt'~ivm10tt'~ivm11tt'~ivm12tt'~ivm13tt'; // (baselines, times) can append more: e.g. ~ivmt4'~ivmt5' and so on, based on the number of alternatives
ivmtnw =  ivm1tt'~ivm2tt'~ivm3tt'~ivm4tt'~ivm5tt'~ivm6tt'~ivm7tt'~ivm8tt'~ivm9tt'~ivm10tt'~ivm11tt'~ivm12tt'~ivm13tt'; // (baselines, times) can append more: e.g. ~ivmt4'~ivmt5' and so on, based on the number of alternatives
ivgtw =  ivgwttw'~ivg1ttw'~ivg2ttw'~ivg3ttw'~ivg4ttw'~ivg5ttw'~ivg6ttw'~ivg7ttw'~ivg8ttw'~ivg9ttw'~ivg10ttw'~ivg11ttw'~ivg12ttw'~ivg13ttw'; // (gammas, satiation, times) can append more: e.g. ~ivgt4'~ivgt5' and so on, based on the number of alternatives
ivgtnw = ivg1ttnw'~ivg2ttnw'~ivg3ttnw'~ivg4ttnw'~ivg5ttnw'~ivg6ttnw'~ivg7ttnw'~ivg8ttnw'~ivg9ttnw'~ivg10ttnw'~ivg11ttnw'~ivg12ttnw'~ivg13ttnw'; // (gammas, satiation, times) can append more: e.g. ~ivgt4'~ivgt5' and so on, based on the number of alternatives

// Build utility function components for goods consumption
ivmg =  ivm1gg'~ivm2gg'~ivm3gg'~ivm4gg'~ivm5gg'~ivm6gg'~ivm7gg'~ivm8gg'~ivm9gg'~ivm10gg'~ivm11gg'~ivm12gg'~ivm13gg'~ivm14gg'~ivm15gg'; // (baselines, goods) can append more: e.g. ~ivmt4'~ivmt5' and so on, based on the number of alternatives
ivgg =  ivg1gg'~ivg2gg'~ivg3gg'~ivg4gg'~ivg5gg'~ivg6gg'~ivg7gg'~ivg8gg'~ivg9gg'~ivg10gg'~ivg11gg'~ivg12gg'~ivg13gg'~ivg14gg'~ivg15gg'; // (gammas, satiation, goods) can append more: e.g. ~ivgt4'~ivgt5' and so on, based on the number of alternatives

nvarmw = cols(ivmw);  // number of variables in utility for work   = number of columns in ivmw, do not modify this
nvarmt = cols(ivm1t);  // number of variables in baseline utility for times   = number of columns in ivm1t, do not modify this
nvarmg = cols(ivm1g);  // number of variables in baseline utility for goods   = number of columns in ivm1g, do not modify this
nvargamtw = cols(ivg1tw);   // number of variables in satiation for time     = number of columns in ivg1t plus work, do not modify this
nvargamtnw = cols(ivg1tnw);   // number of variables in satiation for time     = number of columns in ivg1t plus work, do not modify this
nvargamg = cols(ivg1g);   // number of variables in satiation for time     = number of columns in ivg1t pluswork, do not modify thisis
nvarall = nvarmw+nvarmt+nvarmg;

// Associating columns with variable names
flagchmtw = ftw';
flagchmtnw = ftnw';
flagchmg = fg';
flagchmw = fw';
flagavmtw  = ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno;//Append as many "ivuno" as the number of time alternatives (for workers)
flagavmtnw  = ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno;//Append as many "ivuno" as the number of time alternatives (for non-workers)
flagavmg  = ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno~ivuno;//Append as many "ivuno" as the number of goods alternatives
//(all alternatives are considered to be available; if an alternative is not available, use ivsero for that alternative).
flagprcm  = fp';
flaginc   = fi';

/* Do not modify the line below */

hh = zeros(1,numout)~ones(1,nct-numout+nw);

/******************************************************************************
Starting values
******************************************************************************/
/* Creating matrices (EQMATDEL and EQMATGAM) of ones and zeros to define constraints across coefficients of variables;

EQMATDEL should have as many columns as the number of variables in ivd1, ivd2... specifications (i.e., specifications for satiation/alpha parameters)
and as many rows as the number of distinct parameters. So if you have 5 alpha parameters, and youwant the first two to be constrained to be the same,
the next two also constrained to be the same, and the last separate, then the EQMATDEL matrixwill be:

EQMATDEL = { 1 1 0 0 0  ,
0 0 1 1 0  ,
0 0 0 0 1  };

EQMATGAM should have as many columns as the number of variables in ivg1, ivg2... specifications (i.e., specifications for translation/gamma parameters)
and as many rows as the number of distinct parameters. So if you have 5 gamma parameters, and youwant the first two to be constrained to be the same,
the next two constrained to be the same, and the last separate; then the EQMATGAM matrixwill be:

EQMATGAM = { 1 1 0 0 0  ,
0 0 1 1 0  ,
0 0 0 0 1  };    */

/* Below is the code for defining EQMATDEL and EQMATGAM matrices;
These definitions correspond to restricted estimations of the alpha and gamma parameters across alternatives based on the configuration specified (see documentation) */
// Variable order is:work variables, time variables, goods variables, deltawork, delta outside time, delta time, delta outside goods, delta goods,
// gammawork, gamma outside time, gamma time, gamma outside goods, gamma goods

EQMATGAMTW = eye(nct+nw);
EQMATGAMTNW = eye(nct);
EQMATGAMG = eye(ncg);
b = 0.1*ones(nvarall,1)|-1000*ones(numout,1)|zeros((rows(EQMATGAMTW)-numout),1)|-1000*ones(numout,1)|zeros((rows(EQMATGAMTNW)-numout),1)|-1000*ones(numout,1)|zeros((rows(EQMATGAMG)-numout),1);

_max_active = ones(nvarall,1)|zeros(numout,1)|ones((rows(EQMATGAMTW)-numout),1)|zeros(numout,1)|ones((rows(EQMATGAMTNW)-numout),1)|zeros(numout,1)|ones((rows(EQMATGAMG)-numout),1);

/* Defining variable labels in satiation and translation parameter terms for output printing */

varngamtw = 0 $+ "GTW" $+ ftocv(seqa(1,1,rows(EQMATGAMTW)),2,0);
varngamtnw = 0 $+ "GTNW" $+ ftocv(seqa(1,1,rows(EQMATGAMTNW)),2,0);
varngamg = 0 $+ "GG" $+ ftocv(seqa(1,1,rows(EQMATGAMG)),2,0);

b = b|1;  // 1 appended as a starting value for the scale parameter

if _price == 1;
 _max_active = _max_active|1;   // scale estimated if the data contains price variation
else;
 _max_active = _max_active|0;   // scale fixed to 1 if the data does not contain price variation
endif;

// You can also provide your own starting values


/* Other Maxlik globals */
_max_ParNames = varnamw|varnamt|varnamg|varngamtw|varngamtnw|varngamg|"sigm";  // Appending all the parameter (or coefficient) names
//_max_GradProc=&lgd;    COMMENT OUT FOR NOW AND RUNwITH NUMERICAL GRADIENT (SLOWER BUT NEED TO TEST LL FIRST)
_max_Options = { bfgs stepbt };
_max_CovPar = 1;  // modify according to the type of standard errors you need


/******************************************************************************
// ACTUAL PROGRAM AREA BEGINS, YOU DO NOT HAVE TO MODIFY ANYTHING BELOW THIS LINE
// Format of outputs is provided in the documentation
// Note that for the same variable specification, the number of parameters in the output depends upon the chosen configuration (i.e., _config) of the utility function
// Last parameter corresponds to scale,which is restricted to 1 if there is no price variation in the data
******************************************************************************/

{ x,f,g,cov,retcode } = maxprt(maxlik(dataset,0,&lpr,b));

// The above line calls the procedures that provide as output the parameterized versions of Alphas and Gammas, and prints the outputs

// The following code passes those parameters into another procedure (lpr1) to obtain the actual values of Alphas and Gammas, alongwith appropriate standard errors and t-statistics, and print the outputs

clearg _max_gradproc;
b = x[1:nvarall]|exp(x[nvarall+1:nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+rows(EQMATGAMG)])|x[nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+rows(EQMATGAMG)+1];

/* Normally would not need to restrict iterations to zero to get alpha and gamma parameters directly, because unparameterized and parameterized values should be the same;
however, in some cases, such as _alp0to1=1, your parameterized form will guarantee alpha to be between 0 to 1, but direct estimation can get you negative value; Thus,
not allowing optimization when undertaking direct estimation; when _alp0to1=1, you can take this next line out */

 _max_Maxiters = 0;

{ x,f,g,cov,retcode } = maxprt(maxlik(dataset,0,&lpr1,b));

/******************************************************************************
Procedure definitions begin
******************************************************************************/

/* procedure for log likelihood function calculation */
proc lpr(x,dta);
 local e1,popass,wgt,p0,xgamtw,xgamtnw,xgamg,v2tw,v2tnw,v2g,v2w,w2t,u2tw,u2tnw,
    w2g,u2g,j,vt,vtw,vtnw,vg,wt,wg,utw,utnw,ut,ug,btw,btnw,bg,mtw,mtnw,mg,c,ct,cg,xsig,ylarge1,ylarge2,
  fin,as,ass,r,err,ylarge,xsigm,vv,vlos,dt,dg,et,eg,p1,p2,p3,z,znw,zw,ztw,ztnw,zg,w1,z1,d,ftw,ftnw,fg,w,tmpDta;
 e1 = rows(dta);
 wgt = dta[.,wtind];
 popass = dta[.,_po];
 
 // Variable order is:work/no work variables, time variables, goods variables,
 // gammawork, gamma outside time, gamma time, gamma outside goods, gamma go
 
 v2w = ((x[1:nvarmw])*~(dta[.,ivmw])')';
    
 xgamtw = EQMATGAMTW'*x[nvarall+1:nvarall+rows(EQMATGAMTW)];
 xgamtnw = EQMATGAMTNW'*x[nvarall+rows(EQMATGAMTW)+1:nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)];
 v2tw   = (ones(nct+nw,1) .*. x[nvarmw+1:nvarmw+nvarmt])*~(dta[.,ivmtw])';
 v2tnw  = (ones(nct,1) .*. x[nvarmw+1:nvarmw+nvarmt])*~(dta[.,ivmtnw])';
 u2tw  = (ones(nct+nw,1) .*. xgamtw)*~(dta[.,ivgtw])';
 u2tnw = (ones(nct,1) .*. xgamtnw)*~(dta[.,ivgtnw])';
 
 xgamg = EQMATGAMG'*x[nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+1:nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+rows(EQMATGAMG)];
 xsigm = x[nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+rows(EQMATGAMG)+1];
 v2g = (ones(ncg,1) .*. x[nvarmw+nvarmt+1:nvarall])*~(dta[.,ivmg])';
 u2g = (ones(ncg,1) .*. xgamg)*~(dta[.,ivgg])';
 
 /* During the parameter search, sometimes the value of x[rows(x)] (i.e., the scale parameter) may go below 0.
 The command below helps the iterations get back on track. Note that final resultswill generally not be affected by this;
 If affected, youwill get a negative value printed for sigm (scale) in the output   */
 
 if xsigm<=0;
  xsigm=1;
 endif;

 vtw = {};
 utw = {};
 vtnw = {};
 utnw = {};
 
 vg = {};
 ug = {};

 // Takes matrix of choices * observations by variables and sums across variables, then appends by number of choices,
 //which were column vectorized above
 for j(1,nct+nw,1);
  vtw = vtw~(sumc(v2tw[(j-1)*nvarmt+1:(j*nvarmt),.]));
  utw = utw~(sumc(u2tw[(j-1)*nvargamtw+1:(j*nvargamtw),.]));
 endfor;
 for j(1,nct,1);
  vtnw = vtnw~(sumc(v2tnw[(j-1)*nvarmt+1:(j*nvarmt),.]));
  utnw = utnw~(sumc(u2tnw[(j-1)*nvargamtnw+1:(j*nvargamtnw),.]));
 endfor;
 for j(1,ncg,1);
  vg = vg~(sumc(v2g[(j-1)*nvarmg+1:(j*nvarmg),.]));
  ug = ug~(sumc(u2g[(j-1)*nvargamg+1:(j*nvargamg),.]));
 endfor;
 
 utw[.,1:numout]=-1000*ones(e1,numout);
 utnw[.,1:numout]=-1000*ones(e1,numout);
 ug[.,1:numout]=-1000*ones(e1,numout);
 clear v2tw,v2tnw,v2g,w2t,w2g;
 
 // Calculate the probability of choosing to not work
 w = exp(sumr(v2w[.,1]))./(1+exp(sumr(v2w[.,1])));
 
 ftw = exp(utw);
 ftnw = exp(utnw);
 fg = exp(ug);
 btw = dta[.,flagchmtw] .> 0;
 btnw = dta[.,flagchmtnw] .> 0;
 bg = dta[.,flagchmg] .> 0;
 mtw = sumc((btw'));
 mtnw = sumc((btnw'));
 mg = sumc((bg'));
 // Jacobian terms = 1 / (optimal value - minimum value (assume zero for now) + gamma)
 // Perform calculation assuming no work
 ct = 1./(dta[.,flagchmtnw]+ftnw);
 cg = 1./(dta[.,flagchmg]+fg);
 ct = substute(ct,btnw.==0,1);
 cg = substute(cg,bg.==0,1);
 et = (1/ct).*btnw;
 eg = (1/cg).*bg;
 dt = sumc((et'));
 dg = sumc((cg'));
 ct = prodc((ct')).*dt;
 cg = prodc((cg')).*dg;
 c = ct.*cg.*dta[.,flagchmw];
 // Add the same term assuming work
 // Cludgy solution, but temporarily replace work hours for non-workers with 1.0. 
 // Doesn't affect estimation because only multiplying jacobian by 1.0.
 tmpDta = dta[.,flagchmtw];
 tmpDta = substute(tmpDta,btw.==0,1);
 ct = 1./(tmpDta+ftw);
 cg = 1./(dta[.,flagchmg]+fg);
 ct = substute(ct,btw.==0,1);
 cg = substute(cg,bg.==0,1);
 et = (1/ct).*btw;
 eg = (1/cg).*bg;
 dt = sumc((et'));
 dg = sumc((cg'));
 ct = prodc((ct')).*dt;
 cg = prodc((cg')).*dg;
 c = c + ct.*cg.*(1-dta[.,flagchmw]);
 // Calculate time consumption component (assuming work)
 vtw[.,1:nw] = -ln(tmpDta[.,1:nw]+ftw[.,1:nw]);
 vtw[.,nw+1:nct+nw] = -ln((dta[.,flagchmtw[nw+1:nct+nw]]+ftw[.,nw+1:nct+nw])./(ftw[.,nw+1:nct+nw]))
  +vtw[.,nw+1:nct+nw];
 vtw = substute(vtw,dta[.,flagchmw].==0,0);
 ut = (vtw./xsigm);
 p1 = exp(ut);
 p2 = (p1.*dta[.,flagavmtw])./sumc((p1.*dta[.,flagavmtw])');
 p3 = substute(p2,btw.==0,1);
 p3 = (prodc((p3'))).*c.*((mtw-1)!);
 p3 = p3./((xsigm)^(mtw-1));
 ztw = p3;
 // Calculate time consumption component (assuming no work)
 vtnw[.,1:numout] = -ln(dta[.,flagchmtnw[1:numout]]+ftnw[.,1:numout]);
 vtnw[.,numout+1:nct] = -ln((dta[.,flagchmtnw[numout+1:nct]]+ftnw[.,numout+1:nct])./(ftnw[.,numout+1:nct]))
  +vtnw[.,numout+1:nct];
 ut = vtnw./xsigm;
 p1 = exp(ut);
 p2 = (p1.*dta[.,flagavmtnw])./sumc((p1.*dta[.,flagavmtnw])');
 p3 = substute(p2,btnw.==0,1);
 p3 = (prodc((p3'))).*c.*((mtnw-1)!);
 p3 = p3./((xsigm)^(mtnw-1));
 ztnw = p3;

 // Calculate goods consumption component
 vg[.,1:numout] = -ln(dta[.,flagchmg[1:numout]]);
 vg[.,numout+1:ncg] = -ln((dta[.,flagchmg[numout+1:ncg]]+fg[.,numout+1:ncg])./(fg[.,numout+1:ncg]))
  +vg[.,numout+1:ncg];
 ug = vg./xsigm;
 p1 = exp(ug);
 p2 = (p1.*dta[.,flagavmg])./sumc((p1.*dta[.,flagavmg])');
 p3 = substute(p2,bg.==0,1);
 p3 = (prodc((p3'))).*c.*((mg-1)!);
 p3 = p3./((xsigm)^(mg-1));
 zg = p3;
 
 // Combine likelihood components
 znw = (ztnw.*zg.*w);
 zw = (ztw.*zg.*(1-w));
 z = znw.*dta[.,flagchmw] + zw.*(1-dta[.,flagchmw]);
 w1=zeros(e1,1);
 
 if z >w1;
  z1=ln(znw).*dta[.,flagchmw]+ln(zw).*(1-dta[.,flagchmw]);
 else;
  print "yes";
  z1=ln(znw-((znw.<=w1).*(znw-0.0001))).*dta[.,flagchmw]+ln(zw-((zw.<=w1).*(zw-0.0001))).*(1-dta[.,flagchmw]);
  z1=ln(z-((z.<=w1).*(z-0.0001)));
 endif;
 retp(wgt.*z1);
endp;


/* Procedure for gradient function corresponding to the above log-likelihood fucntion, lpr*/
//proc lgd(x,dta);
// local e1,popass,p0,xdel,xgam,v2,w2,u2,j,v,w,u,a,b,m,c,xsig,ylarge1,ylarge2,fin,as,ass,r,err,ylarge,
//   vv,vlos,ut,uts,f1,p1,p2,p3,z,w1,z1,d,e;
// local gv,gd,gg,gge,g1,g1s,g2,h,g2v,g2d,g2g,g2e,ylargev,giterv,giterd,giterg,gitere;
// local xsigm,xcov,xcov1,giterr,s,asr,assr,errr;
// local bb,g2s,as1,ass1,ggr,err1,g2r,g4,g5,gitere1,wt;
// e1 = rows(dta);
//wt = dta[.,wtind];
// popass = dta[.,_po];
// p0 = zeros(e1,1);
// xdel = EQMATDEL'*x[nvarm+1:nvarm+rows(EQMATDEL)];
// xgam = EQMATGAM'*x[nvarm+rows(EQMATDEL)+1:nvarm+rows(EQMATDEL)+rows(EQMATGAM)];
// xsigm = x[nvarm+rows(EQMATDEL)+rows(EQMATGAM)+1];
// v2 = (ones(nc,1) .*. x[1:nvarm])*~(dta[.,ivm])';
//w2 = (ones(nc,1) .*. xdel)*~(dta[.,ivd])';
// u2 = (ones(nc,1) .*. xgam)*~(dta[.,ivg])';

// v = {};
//w = {};
// u = {};
// for j(1,nc,1);
//   v = v~(sumc(v2[(j-1)*nvarm+1:(j*nvarm),.]));
//  w =w~(sumc(w2[(j-1)*nvardel+1:(j*nvardel),.]));
//   u = u~(sumc(u2[(j-1)*nvargam+1:(j*nvargam),.]));
// endfor;
// u[.,1:numout]=-1000*ones(e1,numout);
// clear v2,w2;

// a = exp(w); /* a is (1-Alpha) */
// if _alp0to1;
//   a = 1/(1+exp(w));
// endif;

// f = exp(u);
// b = dta[.,flagchm] .> 0;
// m = sumc((b'));
// c = (a.*b)./((dta[.,flagchm]+f));
// c = c./(dta[.,flagprcm]);
// c = substute(c,b.==0,1);
// e = (1/c).*b;
// d = sumc((e'));
// c = (prodc((c'))).*d;
// v[.,1:numout] = v[.,1:numout]-a[.,1:numout].*ln(dta[.,flagchm[1:numout]]+f[.,1:numout])-ln(dta[.,flagprcm[1:numout]]);
// v[.,numout+1:nc] = v[.,numout+1:nc]-a[.,numout+1:nc].*ln((dta[.,flagchm[numout+1:nc]]+f[.,numout+1:nc])./f[.,numout+1:nc])-ln(dta[.,flagprcm[numout+1:nc]]);
// ut = v./xsigm;
// uts = -ut./xsigm;
// p1 = exp(ut);
// p2 = (p1.*dta[.,flagavm])./sumc((p1.*dta[.,flagavm])');
// p3 = substute(p2,b.==0,1);
// p3 = (prodc((p3'))).*c.*((m-1)!);
// p3 = p3./((xsigm)^(m-1));

// g1 = (ones(e1,1) .*.eye(nc)) - (p2 .*. ones(nc,1));
// g1 = g1.*vecr(b);
// g1s = g1.*(uts.*.ones(nc,1));
// g2 = {};
// g2s = {};
// for j(1,e1,1);
//   g2 = g2~(sumc(g1[(j-1)*nc+1:(j*nc),.]));
//   g2s = g2s~(sumc(g1s[(j-1)*nc+1:(j*nc),.]));
// endfor;

// clear g1;
// h = dta[.,flagchm]+f;
// g2 = (1/xsigm).*(g2').*p3;
// f1 = (1-hh)+hh.*f;
// g2s = (sumc(g2s)-((m-1)/xsigm));

// if _alp0to1 == 0;
//   g2d = g2.*(((ln(h./f1)).*(-a)))+p3.*b+p3.*(e./d).*(-1);
// else;
//  g2d = g2.*(((ln(h./f1)).*(a.*(1-a))))+p3.*(a-1).*b+p3.*(e./d).*(1-a);
// endif;

// g2g = (g2.*(-a).*(1./h).*(-1/f1).*dta[.,flagchm]+p3.*(-1./h).*b+p3.*(e./d).*(1./h)).*f;
// g2v = ones(1,nvarm).*.g2';
// g2d = ones(1,nvardel).*.g2d';
// g2g = ones(1,nvargam).*.g2g';
// ylargev= dta[.,ivm];
// gv = (reshape((sumc(g2v.*(reshape(ylargev',nc,e1*nvarm))))',nvarm,e1))';
// gd = (reshape((sumc(g2d.*(reshape(((dta[.,ivd])'),nc,e1*nvardel))))',nvardel,e1))';
// gg = (reshape((sumc(g2g.*(reshape(((dta[.,ivg])'),nc,e1*nvargam))))',nvargam,e1))';
// retp(wt.*(((gv~gd*EQMATDEL'~gg*EQMATGAM')./p3)~g2s));
//endp;


/* Procedure to obtain actual values of Alphas and Gammas */
proc lpr1(x,dta);
 local e1,popass,wgt,p0,xgamtw,xgamtnw,xgamg,v2tw,v2tnw,v2g,v2w,w2t,u2tw,u2tnw,
    w2g,u2g,j,vt,vtw,vtnw,vg,wt,wg,utw,utnw,ut,ug,btw,btnw,bg,mtw,mtnw,mg,c,ct,cg,xsig,ylarge1,ylarge2,
 fin,as,ass,r,err,ylarge,xsigm,vv,vlos,dt,dg,et,eg,p1,p2,p3,z,znw,zw,ztw,ztnw,zg,w1,z1,d,ftw,ftnw,fg,w,tmpDta;
 
 e1 = rows(dta);
 wgt = dta[.,wtind];
 popass = dta[.,_po];

 // Variable order is:work/non work variables, time variables, goods variables,
 // gammawork, gamma outside time, gamma time, gamma outside goods, gamma go
    
 v2w = ((x[1:nvarmw])*~(dta[.,ivmw])')';
    
 xgamtw = EQMATGAMTW'*x[nvarall+1:nvarall+rows(EQMATGAMTW)];
 xgamtnw = EQMATGAMTNW'*x[nvarall+rows(EQMATGAMTW)+1:nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)];
 v2tw   = (ones(nct+nw,1) .*. x[nvarmw+1:nvarmw+nvarmt])*~(dta[.,ivmtw])';
 v2tnw  = (ones(nct,1) .*. x[nvarmw+1:nvarmw+nvarmt])*~(dta[.,ivmtnw])';   
 u2tw  = (ones(nct+nw,1) .*. xgamtw)*~(dta[.,ivgtw])';
 u2tnw = (ones(nct,1) .*. xgamtnw)*~(dta[.,ivgtnw])';

 xgamg = EQMATGAMG'*x[nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+1:nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+rows(EQMATGAMG)];
 xsigm = x[nvarall+rows(EQMATGAMTW)+rows(EQMATGAMTNW)+rows(EQMATGAMG)+1];
 v2g = (ones(ncg,1) .*. x[nvarmw+nvarmt+1:nvarall])*~(dta[.,ivmg])';
 u2g = (ones(ncg,1) .*. xgamg)*~(dta[.,ivgg])';
 
 /* During the parameter search, sometimes the value of x[rows(x)] (i.e., the scale parameter) may go below 0.
 The command below helps the iterations get back on track. Note that final resultswill generally not be affected by this;
 If affected, youwill get a negative value printed for sigm (scale) in the output   */
 
 if xsigm<=0;
  xsigm=1;
 endif;
 
 vtw = {};
 utw = {};
 vtnw = {};
 utnw = {};
 
 vg = {};
 ug = {};

 // Takes matrix of choices * observations by variables and sums across variables, then appends by number of choices,
 //which were column vectorized above
 for j(1,nct+nw,1);
  vtw = vtw~(sumc(v2tw[(j-1)*nvarmt+1:(j*nvarmt),.]));
  utw = utw~(sumc(u2tw[(j-1)*nvargamtw+1:(j*nvargamtw),.]));
 endfor;
 for j(1,nct,1);
  vtnw = vtnw~(sumc(v2tnw[(j-1)*nvarmt+1:(j*nvarmt),.]));
  utnw = utnw~(sumc(u2tnw[(j-1)*nvargamtnw+1:(j*nvargamtnw),.]));
 endfor;
 for j(1,ncg,1);
  vg = vg~(sumc(v2g[(j-1)*nvarmg+1:(j*nvarmg),.]));
  ug = ug~(sumc(u2g[(j-1)*nvargamg+1:(j*nvargamg),.]));
 endfor;
 
 utw[.,1:numout]=-1000*ones(e1,numout);
 utnw[.,1:numout]=-1000*ones(e1,numout);
 ug[.,1:numout]=-1000*ones(e1,numout);
 clear v2tw,v2tnw,v2g,w2t,w2g;

 // Calculate the probability of choosing to not work
 w = exp(sumr(v2w[.,1]))./(1+exp(sumr(v2w[.,1])));
 
 ftw = exp(utw);
 ftnw = exp(utnw);
 fg = exp(ug);
 btw = dta[.,flagchmtw] .> 0;
 btnw = dta[.,flagchmtnw] .> 0;
 bg = dta[.,flagchmg] .> 0;
 mtw = sumc((btw'));
 mtnw = sumc((btnw'));
 mg = sumc((bg'));
 // Jacobian terms = 1 / (optimal value - minimum value (assume zero for now) + gamma)
 // Perform calculation assuming no work
 ct = 1./(dta[.,flagchmtnw]+ftnw);
 cg = 1./(dta[.,flagchmg]+fg);
 ct = substute(ct,btnw.==0,1);
 cg = substute(cg,bg.==0,1);
 et = (1/ct).*btnw;
 eg = (1/cg).*bg;
 dt = sumc((et'));
 dg = sumc((cg'));
 ct = prodc((ct')).*dt;
 cg = prodc((cg')).*dg;
 c = ct.*cg.*dta[.,flagchmw];
 // Add the same term assuming work
 // Cludgy solution, but temporarily replace work hours for non-workers with 1.0. 
 // Doesn't affect estimation because only multiplying jacobian by 1.0.
 tmpDta = dta[.,flagchmtw];
 tmpDta = substute(tmpDta,btw.==0,1);
 ct = 1./(tmpDta+ftw);
 cg = 1./(dta[.,flagchmg]+fg);
 ct = substute(ct,btw.==0,1);
 cg = substute(cg,bg.==0,1);
 et = (1/ct).*btw;
 eg = (1/cg).*bg;
 dt = sumc((et'));
 dg = sumc((cg'));
 ct = prodc((ct')).*dt;
 cg = prodc((cg')).*dg;
 c = c + ct.*cg.*(1-dta[.,flagchmw]); 
 
 // Calculate time consumption component (assuming work)
 vtw[.,1:nw] = -ln(tmpDta[.,1:nw]+ftw[.,1:nw]);
 vtw[.,nw+1:nct+nw] = -ln((dta[.,flagchmtw[nw+1:nct+nw]]+ftw[.,nw+1:nct+nw])./(ftw[.,nw+1:nct+nw]))
  +vtw[.,nw+1:nct+nw];
 vtw = substute(vtw,dta[.,flagchmw].==0,0);
 ut = (vtw./xsigm);
 p1 = exp(ut);
 p2 = (p1.*dta[.,flagavmtw])./sumc((p1.*dta[.,flagavmtw])');
 p3 = substute(p2,btw.==0,1);
 p3 = (prodc((p3'))).*c.*((mtw-1)!);
 p3 = p3./((xsigm)^(mtw-1));
 ztw = p3;
 // Calculate time consumption component (assuming no work)
 vtnw[.,1:numout] = -ln(dta[.,flagchmtnw[1:numout]]+ftnw[.,1:numout]);
 vtnw[.,numout+1:nct] = -ln((dta[.,flagchmtnw[numout+1:nct]]+ftnw[.,numout+1:nct])./(ftnw[.,numout+1:nct]))
  +vtnw[.,numout+1:nct];
 ut = vtnw./xsigm;
 p1 = exp(ut);
 p2 = (p1.*dta[.,flagavmtnw])./sumc((p1.*dta[.,flagavmtnw])');
 p3 = substute(p2,btnw.==0,1);
 p3 = (prodc((p3'))).*c.*((mtnw-1)!);
 p3 = p3./((xsigm)^(mtnw-1));
 ztnw = p3;

 // Calculate goods consumption component
 vg[.,1:numout] = -ln(dta[.,flagchmg[1:numout]]);
 vg[.,numout+1:ncg] = -ln((dta[.,flagchmg[numout+1:ncg]]+fg[.,numout+1:ncg])./(fg[.,numout+1:ncg]))
  +vg[.,numout+1:ncg];
 ug = vg./xsigm;
 p1 = exp(ug);
 p2 = (p1.*dta[.,flagavmg])./sumc((p1.*dta[.,flagavmg])');
 p3 = substute(p2,bg.==0,1);
 p3 = (prodc((p3'))).*c.*((mg-1)!);
 p3 = p3./((xsigm)^(mg-1));
 zg = p3;
 
 // Combine likelihood components
 znw = (ztnw.*zg.*w);
 zw = (ztw.*zg.*(1-w));
 z = znw.*dta[.,flagchmw] + zw.*(1-dta[.,flagchmw]);
 w1=zeros(e1,1);
 
 if z >w1;
  z1=ln(znw).*dta[.,flagchmw]+ln(zw).*(1-dta[.,flagchmw]);
 else;
  print "yes";
  z1=ln(znw-((znw.<=w1).*(znw-0.0001))).*dta[.,flagchmw]+ln(zw-((zw.<=w1).*(zw-0.0001))).*(1-dta[.,flagchmw]);
  z1=ln(z-((z.<=w1).*(z-0.0001)));
 endif;
 retp(wgt.*z1);
endp;
